/**
 * 검색엔진 수준 프리로딩 서비스
 * 첫 페이지 접속 시 필요한 모든 데이터를 단일 쿼리로 미리 로드
 */

import { prisma } from '@/lib/db/prisma';
import { standardizeCampaign } from '@/lib/utils/api-standardizer';
import { logger } from '@/lib/logger';
import fs from 'fs/promises';
import path from 'path';

export interface PreloadedData {
  campaigns: any[];
  sections: any[];
  languagePacks: Record<string, any>;
  categoryStats: Record<string, number>;
  metadata: {
    totalCampaigns: number;
    loadTime: number;
    cached: boolean;
  };
}

// 메모리 캐시 - TTL 단축 및 메모리 효율화
let preloadedCache: PreloadedData | null = null;
let cacheTimestamp: number = 0;
const CACHE_TTL = 5 * 60 * 1000; // 5분으로 단축 (메모리 절약)

/**
 * 모든 홈페이지 데이터를 단일 트랜잭션으로 프리로드
 * 검색엔진처럼 첫 접속 시 필요한 모든 데이터를 한 번에 가져옴
 */
export async function preloadHomePageData(): Promise<PreloadedData> {
  const startTime = Date.now();
  
  // 캐시 확인
  if (preloadedCache && (Date.now() - cacheTimestamp) < CACHE_TTL) {
    logger.info('Returning cached preloaded data');
    return {
      ...preloadedCache,
      metadata: {
        ...preloadedCache.metadata,
        cached: true,
        loadTime: Date.now() - startTime
      }
    };
  }

  try {
    // 1. JSON 캐시 파일에서 캠페인 데이터 읽기 시도
    let campaignsData: any[] = [];
    let campaignsFromCache = false;
    
    try {
      const cacheFile = path.join(process.cwd(), 'public/cache/campaigns.json');
      const cacheContent = await fs.readFile(cacheFile, 'utf-8');
      const cachedData = JSON.parse(cacheContent);
      
      // 캐시 나이 확인 (1분 이내만 사용)
      const cacheAge = Date.now() - new Date(cachedData.generatedAt).getTime();
      if (cacheAge < 60000) {
        campaignsData = cachedData.featured || [];
        campaignsFromCache = true;
        logger.info(`Using JSON cache for campaigns (age: ${Math.floor(cacheAge/1000)}s)`);
      }
    } catch (error) {
      logger.info('JSON cache not available, falling back to database');
    }
    
    // 캠페인 캐시가 없으면 DB에서 조회
    if (!campaignsFromCache) {
      campaignsData = await prisma.campaign.findMany({
        where: {
          status: 'ACTIVE',
          deletedAt: null
        },
        select: {
          id: true,
          title: true,
          platform: true,
          budget: true,
          targetFollowers: true,
          endDate: true,
          rewardAmount: true,
          maxApplicants: true,
          thumbnailImageUrl: true,
          hashtags: true,
          createdAt: true,
          categories: {
            select: {
              isPrimary: true,
              category: {
                select: {
                  id: true,
                  name: true,
                  slug: true
                }
              }
            }
          },
          business: {
            select: {
              id: true,
              name: true,
              businessProfile: {
                select: {
                  companyName: true
                }
              }
            }
          },
          _count: {
            select: {
              applications: {
                where: { deletedAt: null }
              }
            }
          }
        },
        orderBy: [
          { status: 'desc' },
          { applications: { _count: 'desc' } },
          { createdAt: 'desc' }
        ],
        take: 20
      });
    }
    
    // 단일 트랜잭션으로 나머지 데이터 조회
    const [sectionsData, languagePacksData, categoryStatsData] = await Promise.all([

      // 2. UI 섹션 데이터
      prisma.uISection.findMany({
        where: { 
          visible: true,
          type: { in: ['hero', 'category', 'quicklinks', 'promo', 'ranking', 'recommended'] }
        },
        select: {
          id: true,
          type: true,
          sectionId: true,
          title: true,
          subtitle: true,
          content: true,
          translations: true,
          visible: true,
          order: true
        },
        orderBy: { order: 'asc' }
      }),

      // 3. 언어팩 데이터
      prisma.languagePack.findMany({
        select: {
          id: true,
          key: true,
          ko: true,
          en: true,
          jp: true,
          category: true
        }
      }),

      // 4. 카테고리 통계 - 원시 쿼리로 최적화
      prisma.$queryRaw<Array<{
        categoryId: string;
        slug: string;
        name: string;
        campaignCount: bigint;
      }>>`
        SELECT 
          cc."categoryId",
          c.slug,
          c.name,
          COUNT(*)::bigint as "campaignCount"
        FROM "campaign_categories" cc
        INNER JOIN "categories" c ON cc."categoryId" = c.id
        INNER JOIN "campaigns" camp ON cc."campaignId" = camp.id
        WHERE camp.status = 'ACTIVE' 
          AND camp."deletedAt" IS NULL
        GROUP BY cc."categoryId", c.slug, c.name
        ORDER BY "campaignCount" DESC
        LIMIT 20
      `
    ]);

    // 데이터 변환 및 표준화
    let campaigns: any[];
    
    if (campaignsFromCache) {
      // 캐시된 데이터는 이미 변환된 형태
      campaigns = campaignsData.map(campaign => ({
        ...campaign,
        brand: campaign.business?.name || campaign.business?.companyName || '',
        applicants: campaign.stats?.applications || 0,
        maxApplicants: campaign.maxApplicants || 0,
        deadline: new Date(campaign.deadline || campaign.endDate).getTime(),
        category: campaign.category?.name || '',
        platforms: campaign.platforms || [],
        budget: typeof campaign.budget === 'string' ? campaign.budget : `${campaign.budget?.toLocaleString()}원`,
        imageUrl: campaign.thumbnailUrl || campaign.thumbnailImageUrl
      }));
    } else {
      // DB 데이터는 standardizeCampaign으로 변환
      campaigns = campaignsData.map(campaign => {
        const standardized = standardizeCampaign(campaign);
        return {
          ...standardized,
          brand: standardized.business.name,
          applicants: standardized.stats.applications,
          maxApplicants: standardized.target.maxApplicants,
          deadline: new Date(standardized.schedule.campaign.endDate).getTime(),
          category: standardized.primaryCategory.name,
          platforms: standardized.platforms.map(p => p.type),
          budget: `${standardized.budget.amount.toLocaleString()}원`,
          imageUrl: standardized.media.thumbnail?.url
        };
      });
    }
    
    const languagePacks = languagePacksData.reduce((acc, pack) => {
      acc[pack.key] = pack;
      return acc;
    }, {} as Record<string, any>);

    const categoryStats: Record<string, number> = {};
    categoryStatsData.forEach(stat => {
      categoryStats[stat.slug] = Number(stat.campaignCount);
    });

    const result: PreloadedData = {
      campaigns,
      sections: sectionsData,
      languagePacks,
      categoryStats,
      metadata: {
        totalCampaigns: campaigns.length,
        loadTime: Date.now() - startTime,
        cached: false
      }
    };

    // 캐시 저장
    preloadedCache = result;
    cacheTimestamp = Date.now();

    logger.info(`Preloaded homepage data in ${result.metadata.loadTime}ms - campaigns: ${campaigns.length}, sections: ${sectionsData.length}, languagePacks: ${Object.keys(languagePacks).length}, categories: ${Object.keys(categoryStats).length}`);

    return result;

  } catch (error) {
    logger.error(`Failed to preload homepage data: ${String(error)}`);
    
    // 실패 시 최소한의 데이터 반환
    return {
      campaigns: [],
      sections: [],
      languagePacks: {},
      categoryStats: {},
      metadata: {
        totalCampaigns: 0,
        loadTime: Date.now() - startTime,
        cached: false
      }
    };
  }
}

/**
 * 캐시 무효화
 */
export function invalidatePreloadCache(): void {
  preloadedCache = null;
  cacheTimestamp = 0;
  logger.info('Preload cache invalidated');
}

/**
 * 백그라운드에서 캐시 갱신
 */
export async function refreshCacheInBackground(): Promise<void> {
  try {
    await preloadHomePageData();
    logger.info('Background cache refresh completed');
  } catch (error) {
    logger.error(`Background cache refresh failed: ${String(error)}`);
  }
}