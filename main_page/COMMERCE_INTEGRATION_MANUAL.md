# üõçÔ∏è Ïª§Î®∏Ïä§ ÌÜµÌï© ÏÉÅÏÑ∏ Îß§Îâ¥Ïñº

## Î™©Ï∞®
1. [ÏãúÏûëÌïòÍ∏∞](#ÏãúÏûëÌïòÍ∏∞)
2. [Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ ÏÑ§Í≥Ñ](#Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§-ÏÑ§Í≥Ñ)
3. [API Íµ¨ÌòÑ](#api-Íµ¨ÌòÑ)
4. [ÌîÑÎ°†Ìä∏ÏóîÎìú Íµ¨ÌòÑ](#ÌîÑÎ°†Ìä∏ÏóîÎìú-Íµ¨ÌòÑ)
5. [Í≤∞Ï†ú ÏãúÏä§ÌÖú](#Í≤∞Ï†ú-ÏãúÏä§ÌÖú)
6. [Ïû¨Í≥† Í¥ÄÎ¶¨](#Ïû¨Í≥†-Í¥ÄÎ¶¨)
7. [Î∞∞ÏÜ° ÏãúÏä§ÌÖú](#Î∞∞ÏÜ°-ÏãúÏä§ÌÖú)
8. [Î¶¨Î∑∞ ÏãúÏä§ÌÖú](#Î¶¨Î∑∞-ÏãúÏä§ÌÖú)
9. [Ïø†Ìè∞ Î∞è Ìï†Ïù∏](#Ïø†Ìè∞-Î∞è-Ìï†Ïù∏)
10. [Î∂ÑÏÑù Î∞è Î¶¨Ìè¨ÌåÖ](#Î∂ÑÏÑù-Î∞è-Î¶¨Ìè¨ÌåÖ)

## ÏãúÏûëÌïòÍ∏∞

### ÌîÑÎ°úÏ†ùÌä∏ Ï¥àÍ∏∞ ÏÑ§Ï†ï

1. **ÏùòÏ°¥ÏÑ± ÏÑ§Ïπò**
```bash
pnpm install
```

2. **ÌôòÍ≤ΩÎ≥ÄÏàò ÏÑ§Ï†ï**
```bash
cp .env.example .env.local
```

3. **Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ ÎßàÏù¥Í∑∏Î†àÏù¥ÏÖò**
```bash
pnpm prisma generate
pnpm prisma db push
```

## Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ ÏÑ§Í≥Ñ

### 1. ÏÉÅÌíà Ïä§ÌÇ§Îßà

```prisma
// prisma/schema.prismaÏóê Ï∂îÍ∞Ä

model Product {
  id              String    @id @default(cuid())
  sku             String    @unique
  name            String
  nameTranslations Json?    // Îã§Íµ≠Ïñ¥ ÏßÄÏõê
  slug            String    @unique
  description     String?   @db.Text
  descriptionTranslations Json?
  
  // Í∞ÄÍ≤© Ï†ïÎ≥¥
  price           Float
  compareAtPrice  Float?    // Ìï†Ïù∏ Ï†Ñ Í∞ÄÍ≤©
  cost            Float?    // ÏõêÍ∞Ä
  
  // Ïπ¥ÌÖåÍ≥†Î¶¨
  categoryId      String
  category        Category  @relation(fields: [categoryId], references: [id])
  
  // Ïù¥ÎØ∏ÏßÄ
  thumbnail       String?
  images          String[]
  
  // Ïû¨Í≥† Í¥ÄÎ¶¨
  trackInventory  Boolean   @default(true)
  stock           Int       @default(0)
  lowStockAlert   Int       @default(10)
  
  // SEO
  metaTitle       String?
  metaDescription String?
  metaKeywords    String[]
  
  // ÏÉÅÌÉú
  status          ProductStatus @default(DRAFT)
  publishedAt     DateTime?
  
  // ÏÜçÏÑ±
  weight          Float?
  dimensions      Json?     // {width, height, depth}
  
  // Í¥ÄÍ≥Ñ
  variants        ProductVariant[]
  reviews         ProductReview[]
  cartItems       CartItem[]
  orderItems      OrderItem[]
  wishlistItems   WishlistItem[]
  
  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt
  
  @@index([categoryId])
  @@index([status])
  @@index([slug])
  @@map("products")
}

enum ProductStatus {
  DRAFT
  ACTIVE
  ARCHIVED
  OUT_OF_STOCK
}

model ProductVariant {
  id          String   @id @default(cuid())
  productId   String
  product     Product  @relation(fields: [productId], references: [id], onDelete: Cascade)
  
  name        String   // e.g., "Size", "Color"
  value       String   // e.g., "Large", "Red"
  sku         String   @unique
  price       Float?   // Î≥ÄÌòï Í∞ÄÍ≤© (nullÏù¥Î©¥ Í∏∞Î≥∏ Í∞ÄÍ≤© ÏÇ¨Ïö©)
  stock       Int      @default(0)
  image       String?
  
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  @@unique([productId, name, value])
  @@map("product_variants")
}
```

### 2. Ïû•Î∞îÍµ¨Îãà Ïä§ÌÇ§Îßà

```prisma
model Cart {
  id          String     @id @default(cuid())
  userId      String?    // nullÏù¥Î©¥ Í≤åÏä§Ìä∏ Ïπ¥Ìä∏
  sessionId   String?    // Í≤åÏä§Ìä∏Ïö© ÏÑ∏ÏÖò ID
  
  items       CartItem[]
  
  createdAt   DateTime   @default(now())
  updatedAt   DateTime   @updatedAt
  expiresAt   DateTime?  // Í≤åÏä§Ìä∏ Ïπ¥Ìä∏ ÎßåÎ£å
  
  user        User?      @relation(fields: [userId], references: [id])
  
  @@unique([userId])
  @@index([sessionId])
  @@map("carts")
}

model CartItem {
  id          String   @id @default(cuid())
  cartId      String
  productId   String
  variantId   String?
  quantity    Int      @default(1)
  
  cart        Cart     @relation(fields: [cartId], references: [id], onDelete: Cascade)
  product     Product  @relation(fields: [productId], references: [id])
  variant     ProductVariant? @relation(fields: [variantId], references: [id])
  
  addedAt     DateTime @default(now())
  
  @@unique([cartId, productId, variantId])
  @@map("cart_items")
}
```

### 3. Ï£ºÎ¨∏ Ïä§ÌÇ§Îßà

```prisma
model Order {
  id              String    @id @default(cuid())
  orderNumber     String    @unique
  userId          String
  
  // Í∏àÏï°
  subtotal        Float
  taxAmount       Float
  shippingAmount  Float
  discountAmount  Float
  totalAmount     Float
  
  // ÏÉÅÌÉú
  status          OrderStatus @default(PENDING)
  paymentStatus   PaymentStatus @default(PENDING)
  
  // Î∞∞ÏÜ° Ï†ïÎ≥¥
  shippingAddress Json
  billingAddress  Json
  shippingMethod  String?
  trackingNumber  String?
  
  // Í≤∞Ï†ú Ï†ïÎ≥¥
  paymentMethod   String?
  paymentId       String?
  
  // Í¥ÄÍ≥Ñ
  items           OrderItem[]
  payments        Payment[]
  shipments       Shipment[]
  
  // Î©îÌÉÄÎç∞Ïù¥ÌÑ∞
  notes           String?
  metadata        Json?
  
  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt
  paidAt          DateTime?
  shippedAt       DateTime?
  deliveredAt     DateTime?
  cancelledAt     DateTime?
  
  user            User      @relation(fields: [userId], references: [id])
  
  @@index([userId])
  @@index([status])
  @@index([orderNumber])
  @@map("orders")
}

enum OrderStatus {
  PENDING
  PROCESSING
  CONFIRMED
  SHIPPED
  DELIVERED
  CANCELLED
  REFUNDED
}

enum PaymentStatus {
  PENDING
  PAID
  FAILED
  REFUNDED
  PARTIAL_REFUNDED
}

model OrderItem {
  id          String   @id @default(cuid())
  orderId     String
  productId   String
  variantId   String?
  
  name        String   // Ï£ºÎ¨∏ ÏãúÏ†êÏùò ÏÉÅÌíàÎ™Ö
  sku         String
  price       Float    // Ï£ºÎ¨∏ ÏãúÏ†êÏùò Í∞ÄÍ≤©
  quantity    Int
  total       Float
  
  order       Order    @relation(fields: [orderId], references: [id], onDelete: Cascade)
  product     Product  @relation(fields: [productId], references: [id])
  variant     ProductVariant? @relation(fields: [variantId], references: [id])
  
  @@map("order_items")
}
```

### 4. Î∞∞ÏÜ° Ïä§ÌÇ§Îßà

```prisma
model ShippingMethod {
  id          String   @id @default(cuid())
  name        String
  description String?
  provider    String   // e.g., "fedex", "ups", "korea_post"
  
  basePrice   Float
  perKgPrice  Float    @default(0)
  
  minDays     Int      // ÏµúÏÜå Î∞∞ÏÜ°Ïùº
  maxDays     Int      // ÏµúÎåÄ Î∞∞ÏÜ°Ïùº
  
  countries   String[] // Î∞∞ÏÜ° Í∞ÄÎä• Íµ≠Í∞Ä
  isActive    Boolean  @default(true)
  
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  @@map("shipping_methods")
}

model Shipment {
  id              String   @id @default(cuid())
  orderId         String
  trackingNumber  String?
  carrier         String?
  status          ShipmentStatus @default(PENDING)
  
  shippedAt       DateTime?
  deliveredAt     DateTime?
  
  order           Order    @relation(fields: [orderId], references: [id])
  
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
  
  @@map("shipments")
}

enum ShipmentStatus {
  PENDING
  PROCESSING
  SHIPPED
  IN_TRANSIT
  DELIVERED
  RETURNED
}
```

## API Íµ¨ÌòÑ

### 1. ÏÉÅÌíà API

```typescript
// src/app/api/products/route.ts
import { NextRequest, NextResponse } from 'next/server';
import prisma from '@/lib/prisma';

export async function GET(request: NextRequest) {
  try {
    const { searchParams } = new URL(request.url);
    
    // ÌïÑÌÑ∞ÎßÅ ÌååÎùºÎØ∏ÌÑ∞
    const category = searchParams.get('category');
    const minPrice = searchParams.get('minPrice');
    const maxPrice = searchParams.get('maxPrice');
    const sort = searchParams.get('sort') || 'createdAt';
    const order = searchParams.get('order') || 'desc';
    const page = parseInt(searchParams.get('page') || '1');
    const limit = parseInt(searchParams.get('limit') || '20');
    
    // ÏøºÎ¶¨ Ï°∞Í±¥ Íµ¨ÏÑ±
    const where: any = {
      status: 'ACTIVE'
    };
    
    if (category) {
      where.categoryId = category;
    }
    
    if (minPrice || maxPrice) {
      where.price = {};
      if (minPrice) where.price.gte = parseFloat(minPrice);
      if (maxPrice) where.price.lte = parseFloat(maxPrice);
    }
    
    // Ï†ÑÏ≤¥ Í∞úÏàò Ï°∞Ìöå
    const total = await prisma.product.count({ where });
    
    // ÏÉÅÌíà Ï°∞Ìöå
    const products = await prisma.product.findMany({
      where,
      include: {
        category: true,
        reviews: {
          select: {
            rating: true
          }
        }
      },
      orderBy: {
        [sort]: order
      },
      skip: (page - 1) * limit,
      take: limit
    });
    
    // ÌèâÍ∑† ÌèâÏ†ê Í≥ÑÏÇ∞
    const productsWithRating = products.map(product => {
      const avgRating = product.reviews.length > 0
        ? product.reviews.reduce((sum, r) => sum + r.rating, 0) / product.reviews.length
        : 0;
      
      return {
        ...product,
        averageRating: avgRating,
        reviewCount: product.reviews.length
      };
    });
    
    return NextResponse.json({
      products: productsWithRating,
      pagination: {
        page,
        limit,
        total,
        totalPages: Math.ceil(total / limit)
      }
    });
  } catch (error) {
    console.error('Product fetch error:', error);
    return NextResponse.json(
      { error: 'Failed to fetch products' },
      { status: 500 }
    );
  }
}

export async function POST(request: NextRequest) {
  try {
    const body = await request.json();
    
    // Í¥ÄÎ¶¨Ïûê Í∂åÌïú Ï≤¥ÌÅ¨
    // ... auth check ...
    
    const product = await prisma.product.create({
      data: {
        ...body,
        slug: generateSlug(body.name),
        status: 'DRAFT'
      }
    });
    
    return NextResponse.json(product);
  } catch (error) {
    console.error('Product creation error:', error);
    return NextResponse.json(
      { error: 'Failed to create product' },
      { status: 500 }
    );
  }
}
```

### 2. Ïû•Î∞îÍµ¨Îãà API

```typescript
// src/app/api/cart/route.ts
import { NextRequest, NextResponse } from 'next/server';
import prisma from '@/lib/prisma';
import { getSession } from '@/lib/auth';

export async function GET(request: NextRequest) {
  try {
    const session = await getSession(request);
    const sessionId = request.cookies.get('cart_session')?.value;
    
    let cart;
    
    if (session?.userId) {
      // Î°úÍ∑∏Ïù∏ ÏÇ¨Ïö©Ïûê
      cart = await prisma.cart.findUnique({
        where: { userId: session.userId },
        include: {
          items: {
            include: {
              product: true,
              variant: true
            }
          }
        }
      });
    } else if (sessionId) {
      // Í≤åÏä§Ìä∏ ÏÇ¨Ïö©Ïûê
      cart = await prisma.cart.findFirst({
        where: { sessionId },
        include: {
          items: {
            include: {
              product: true,
              variant: true
            }
          }
        }
      });
    }
    
    if (!cart) {
      return NextResponse.json({ items: [], total: 0 });
    }
    
    // Ï¥ùÏï° Í≥ÑÏÇ∞
    const total = cart.items.reduce((sum, item) => {
      const price = item.variant?.price || item.product.price;
      return sum + (price * item.quantity);
    }, 0);
    
    return NextResponse.json({
      ...cart,
      total
    });
  } catch (error) {
    console.error('Cart fetch error:', error);
    return NextResponse.json(
      { error: 'Failed to fetch cart' },
      { status: 500 }
    );
  }
}

export async function POST(request: NextRequest) {
  try {
    const body = await request.json();
    const { productId, variantId, quantity = 1 } = body;
    
    const session = await getSession(request);
    const sessionId = request.cookies.get('cart_session')?.value || generateSessionId();
    
    // ÏÉÅÌíà ÌôïÏù∏
    const product = await prisma.product.findUnique({
      where: { id: productId }
    });
    
    if (!product || product.status !== 'ACTIVE') {
      return NextResponse.json(
        { error: 'Product not available' },
        { status: 400 }
      );
    }
    
    // Ïû¨Í≥† ÌôïÏù∏
    if (product.trackInventory && product.stock < quantity) {
      return NextResponse.json(
        { error: 'Insufficient stock' },
        { status: 400 }
      );
    }
    
    // Ïπ¥Ìä∏ Ï∞æÍ∏∞ ÎòêÎäî ÏÉùÏÑ±
    let cart = session?.userId
      ? await prisma.cart.findUnique({ where: { userId: session.userId } })
      : await prisma.cart.findFirst({ where: { sessionId } });
    
    if (!cart) {
      cart = await prisma.cart.create({
        data: {
          userId: session?.userId,
          sessionId: !session?.userId ? sessionId : undefined,
          expiresAt: !session?.userId ? new Date(Date.now() + 30 * 24 * 60 * 60 * 1000) : undefined
        }
      });
    }
    
    // Ïπ¥Ìä∏ ÏïÑÏù¥ÌÖú Ï∂îÍ∞Ä ÎòêÎäî ÏóÖÎç∞Ïù¥Ìä∏
    const existingItem = await prisma.cartItem.findUnique({
      where: {
        cartId_productId_variantId: {
          cartId: cart.id,
          productId,
          variantId: variantId || null
        }
      }
    });
    
    if (existingItem) {
      await prisma.cartItem.update({
        where: { id: existingItem.id },
        data: { quantity: existingItem.quantity + quantity }
      });
    } else {
      await prisma.cartItem.create({
        data: {
          cartId: cart.id,
          productId,
          variantId,
          quantity
        }
      });
    }
    
    const response = NextResponse.json({ success: true });
    
    // Í≤åÏä§Ìä∏Ïùò Í≤ΩÏö∞ ÏÑ∏ÏÖò Ïø†ÌÇ§ ÏÑ§Ï†ï
    if (!session?.userId) {
      response.cookies.set('cart_session', sessionId, {
        httpOnly: true,
        secure: process.env.NODE_ENV === 'production',
        sameSite: 'strict',
        maxAge: 30 * 24 * 60 * 60 // 30Ïùº
      });
    }
    
    return response;
  } catch (error) {
    console.error('Add to cart error:', error);
    return NextResponse.json(
      { error: 'Failed to add to cart' },
      { status: 500 }
    );
  }
}
```

### 3. Ï£ºÎ¨∏ API

```typescript
// src/app/api/orders/route.ts
import { NextRequest, NextResponse } from 'next/server';
import prisma from '@/lib/prisma';
import { getSession } from '@/lib/auth';

export async function POST(request: NextRequest) {
  try {
    const session = await getSession(request);
    if (!session?.userId) {
      return NextResponse.json(
        { error: 'Authentication required' },
        { status: 401 }
      );
    }
    
    const body = await request.json();
    const { shippingAddress, billingAddress, shippingMethodId } = body;
    
    // Ïπ¥Ìä∏ Ï°∞Ìöå
    const cart = await prisma.cart.findUnique({
      where: { userId: session.userId },
      include: {
        items: {
          include: {
            product: true,
            variant: true
          }
        }
      }
    });
    
    if (!cart || cart.items.length === 0) {
      return NextResponse.json(
        { error: 'Cart is empty' },
        { status: 400 }
      );
    }
    
    // Ïû¨Í≥† ÌôïÏù∏
    for (const item of cart.items) {
      if (item.product.trackInventory) {
        const availableStock = item.variant?.stock || item.product.stock;
        if (availableStock < item.quantity) {
          return NextResponse.json(
            { error: `Insufficient stock for ${item.product.name}` },
            { status: 400 }
          );
        }
      }
    }
    
    // Î∞∞ÏÜ°ÎπÑ Í≥ÑÏÇ∞
    const shippingMethod = await prisma.shippingMethod.findUnique({
      where: { id: shippingMethodId }
    });
    
    const subtotal = cart.items.reduce((sum, item) => {
      const price = item.variant?.price || item.product.price;
      return sum + (price * item.quantity);
    }, 0);
    
    const taxAmount = subtotal * 0.1; // 10% ÏÑ∏Í∏à
    const shippingAmount = shippingMethod?.basePrice || 0;
    const totalAmount = subtotal + taxAmount + shippingAmount;
    
    // Ï£ºÎ¨∏ ÏÉùÏÑ±
    const order = await prisma.$transaction(async (tx) => {
      // Ï£ºÎ¨∏ ÏÉùÏÑ±
      const newOrder = await tx.order.create({
        data: {
          orderNumber: generateOrderNumber(),
          userId: session.userId,
          subtotal,
          taxAmount,
          shippingAmount,
          discountAmount: 0,
          totalAmount,
          shippingAddress,
          billingAddress,
          shippingMethod: shippingMethod?.name,
          status: 'PENDING',
          paymentStatus: 'PENDING',
          items: {
            create: cart.items.map(item => ({
              productId: item.productId,
              variantId: item.variantId,
              name: item.product.name,
              sku: item.variant?.sku || item.product.sku,
              price: item.variant?.price || item.product.price,
              quantity: item.quantity,
              total: (item.variant?.price || item.product.price) * item.quantity
            }))
          }
        }
      });
      
      // Ïû¨Í≥† Ï∞®Í∞ê
      for (const item of cart.items) {
        if (item.product.trackInventory) {
          if (item.variantId) {
            await tx.productVariant.update({
              where: { id: item.variantId },
              data: {
                stock: {
                  decrement: item.quantity
                }
              }
            });
          } else {
            await tx.product.update({
              where: { id: item.productId },
              data: {
                stock: {
                  decrement: item.quantity
                }
              }
            });
          }
        }
      }
      
      // Ïπ¥Ìä∏ ÎπÑÏö∞Í∏∞
      await tx.cartItem.deleteMany({
        where: { cartId: cart.id }
      });
      
      return newOrder;
    });
    
    return NextResponse.json(order);
  } catch (error) {
    console.error('Order creation error:', error);
    return NextResponse.json(
      { error: 'Failed to create order' },
      { status: 500 }
    );
  }
}

function generateOrderNumber() {
  const prefix = 'ORD';
  const timestamp = Date.now().toString(36).toUpperCase();
  const random = Math.random().toString(36).substring(2, 6).toUpperCase();
  return `${prefix}-${timestamp}-${random}`;
}
```

## ÌîÑÎ°†Ìä∏ÏóîÎìú Íµ¨ÌòÑ

### 1. ÏÉÅÌíà Î™©Î°ù Ïª¥Ìè¨ÎÑåÌä∏

```typescript
// src/components/products/ProductGrid.tsx
'use client';

import { useState, useEffect } from 'react';
import { useSearchParams } from 'next/navigation';
import ProductCard from './ProductCard';
import ProductFilters from './ProductFilters';
import Pagination from '@/components/ui/Pagination';

export default function ProductGrid() {
  const searchParams = useSearchParams();
  const [products, setProducts] = useState([]);
  const [loading, setLoading] = useState(true);
  const [pagination, setPagination] = useState({
    page: 1,
    limit: 20,
    total: 0,
    totalPages: 0
  });
  
  useEffect(() => {
    fetchProducts();
  }, [searchParams]);
  
  async function fetchProducts() {
    setLoading(true);
    try {
      const params = new URLSearchParams(searchParams);
      params.set('page', pagination.page.toString());
      
      const response = await fetch(`/api/products?${params}`);
      const data = await response.json();
      
      setProducts(data.products);
      setPagination(data.pagination);
    } catch (error) {
      console.error('Failed to fetch products:', error);
    } finally {
      setLoading(false);
    }
  }
  
  if (loading) {
    return <div>Loading...</div>;
  }
  
  return (
    <div className="flex gap-8">
      <aside className="w-64">
        <ProductFilters />
      </aside>
      
      <div className="flex-1">
        <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 gap-6">
          {products.map(product => (
            <ProductCard key={product.id} product={product} />
          ))}
        </div>
        
        <Pagination
          page={pagination.page}
          totalPages={pagination.totalPages}
          onPageChange={(page) => setPagination(prev => ({ ...prev, page }))}
        />
      </div>
    </div>
  );
}
```

### 2. Ïû•Î∞îÍµ¨Îãà Ïª¥Ìè¨ÎÑåÌä∏

```typescript
// src/components/cart/CartDrawer.tsx
'use client';

import { useState, useEffect } from 'react';
import { X } from 'lucide-react';
import { useCart } from '@/hooks/useCart';
import CartItem from './CartItem';
import Button from '@/components/ui/Button';

export default function CartDrawer({ isOpen, onClose }) {
  const { cart, loading, updateQuantity, removeItem } = useCart();
  
  if (!isOpen) return null;
  
  return (
    <div className="fixed inset-0 z-50">
      <div className="absolute inset-0 bg-black/50" onClick={onClose} />
      
      <div className="absolute right-0 top-0 h-full w-96 bg-white shadow-xl">
        <div className="flex items-center justify-between p-4 border-b">
          <h2 className="text-lg font-semibold">Ïû•Î∞îÍµ¨Îãà</h2>
          <button onClick={onClose}>
            <X className="w-5 h-5" />
          </button>
        </div>
        
        <div className="flex-1 overflow-y-auto p-4">
          {cart?.items?.length === 0 ? (
            <p className="text-center text-gray-500">Ïû•Î∞îÍµ¨ÎãàÍ∞Ä ÎπÑÏñ¥ÏûàÏäµÎãàÎã§</p>
          ) : (
            <div className="space-y-4">
              {cart?.items?.map(item => (
                <CartItem
                  key={item.id}
                  item={item}
                  onUpdateQuantity={updateQuantity}
                  onRemove={removeItem}
                />
              ))}
            </div>
          )}
        </div>
        
        {cart?.items?.length > 0 && (
          <div className="border-t p-4">
            <div className="flex justify-between mb-4">
              <span className="font-semibold">Ìï©Í≥Ñ</span>
              <span className="font-bold text-xl">
                ‚Ç©{cart.total.toLocaleString()}
              </span>
            </div>
            
            <Button
              className="w-full"
              onClick={() => window.location.href = '/checkout'}
            >
              Í≤∞Ï†úÌïòÍ∏∞
            </Button>
          </div>
        )}
      </div>
    </div>
  );
}
```

## Í≤∞Ï†ú ÏãúÏä§ÌÖú

### Toss Payments ÌÜµÌï©

```typescript
// src/lib/payments/toss.ts
import { loadTossPayments } from '@tosspayments/payment-sdk';

const clientKey = process.env.NEXT_PUBLIC_TOSS_CLIENT_KEY!;

export async function initTossPayments() {
  return await loadTossPayments(clientKey);
}

export async function requestPayment({
  amount,
  orderId,
  orderName,
  customerName,
  customerEmail,
  successUrl,
  failUrl
}) {
  const tossPayments = await initTossPayments();
  
  return tossPayments.requestPayment('Ïπ¥Îìú', {
    amount,
    orderId,
    orderName,
    customerName,
    customerEmail,
    successUrl,
    failUrl
  });
}
```

## Ïû¨Í≥† Í¥ÄÎ¶¨

### Ïã§ÏãúÍ∞Ñ Ïû¨Í≥† ÏóÖÎç∞Ïù¥Ìä∏

```typescript
// src/lib/inventory/stock-manager.ts
import prisma from '@/lib/prisma';
import { sendLowStockAlert } from '@/lib/notifications';

export async function checkLowStock(productId: string) {
  const product = await prisma.product.findUnique({
    where: { id: productId }
  });
  
  if (product && product.stock <= product.lowStockAlert) {
    await sendLowStockAlert(product);
  }
}

export async function reserveStock(items: CartItem[]) {
  // Ïû¨Í≥† ÏòàÏïΩ Î°úÏßÅ
}

export async function releaseStock(items: CartItem[]) {
  // Ïû¨Í≥† Ìï¥Ï†ú Î°úÏßÅ
}
```

## Î∞∞ÏÜ° ÏãúÏä§ÌÖú

### Î∞∞ÏÜ°Î£å Í≥ÑÏÇ∞

```typescript
// src/lib/shipping/calculator.ts
export function calculateShipping({
  weight,
  dimensions,
  destination,
  method
}) {
  // Î∞∞ÏÜ°Î£å Í≥ÑÏÇ∞ Î°úÏßÅ
  let basePrice = method.basePrice;
  let weightPrice = weight * method.perKgPrice;
  
  // ÏßÄÏó≠Î≥Ñ Ï∂îÍ∞Ä ÏöîÍ∏à
  const zoneMultiplier = getZoneMultiplier(destination);
  
  return (basePrice + weightPrice) * zoneMultiplier;
}
```

## Î¶¨Î∑∞ ÏãúÏä§ÌÖú

```prisma
model ProductReview {
  id          String   @id @default(cuid())
  productId   String
  userId      String
  orderId     String?  // Íµ¨Îß§ ÌôïÏù∏Ïö©
  
  rating      Int      // 1-5
  title       String?
  content     String   @db.Text
  
  images      String[]
  
  isVerified  Boolean  @default(false) // Íµ¨Îß§ ÌôïÏù∏Îê®
  
  helpful     Int      @default(0)
  unhelpful   Int      @default(0)
  
  product     Product  @relation(fields: [productId], references: [id])
  user        User     @relation(fields: [userId], references: [id])
  order       Order?   @relation(fields: [orderId], references: [id])
  
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  @@unique([productId, userId, orderId])
  @@map("product_reviews")
}
```

## Ïø†Ìè∞ Î∞è Ìï†Ïù∏

```prisma
model Coupon {
  id              String   @id @default(cuid())
  code            String   @unique
  description     String?
  
  type            CouponType // PERCENTAGE, FIXED_AMOUNT
  value           Float
  
  minOrderAmount  Float?
  maxDiscount     Float?   // ÏµúÎåÄ Ìï†Ïù∏ Í∏àÏï°
  
  usageLimit      Int?     // Ï†ÑÏ≤¥ ÏÇ¨Ïö© Ï†úÌïú
  usageCount      Int      @default(0)
  userLimit       Int?     // ÏÇ¨Ïö©ÏûêÎãπ Ï†úÌïú
  
  validFrom       DateTime
  validUntil      DateTime
  
  isActive        Boolean  @default(true)
  
  appliedOrders   Order[]
  
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
  
  @@map("coupons")
}

enum CouponType {
  PERCENTAGE
  FIXED_AMOUNT
  FREE_SHIPPING
}
```

## Î∂ÑÏÑù Î∞è Î¶¨Ìè¨ÌåÖ

### ÌåêÎß§ Î∂ÑÏÑù ÎåÄÏãúÎ≥¥Îìú

```typescript
// src/app/admin/analytics/page.tsx
export default async function AnalyticsPage() {
  const stats = await getAnalytics();
  
  return (
    <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-6">
      <StatCard
        title="Ï¥ù Îß§Ï∂ú"
        value={`‚Ç©${stats.totalRevenue.toLocaleString()}`}
        change={stats.revenueChange}
      />
      <StatCard
        title="Ï£ºÎ¨∏ Ïàò"
        value={stats.totalOrders}
        change={stats.ordersChange}
      />
      <StatCard
        title="ÌèâÍ∑† Ï£ºÎ¨∏ Í∏àÏï°"
        value={`‚Ç©${stats.averageOrderValue.toLocaleString()}`}
        change={stats.aovChange}
      />
      <StatCard
        title="Ï†ÑÌôòÏú®"
        value={`${stats.conversionRate}%`}
        change={stats.conversionChange}
      />
    </div>
  );
}
```

## Î≥¥Ïïà Í≥†Î†§ÏÇ¨Ìï≠

1. **Í≤∞Ï†ú Î≥¥Ïïà**
   - PCI DSS Ï§ÄÏàò
   - Ïπ¥Îìú Ï†ïÎ≥¥ ÏßÅÏ†ë Ï†ÄÏû• Í∏àÏßÄ
   - HTTPS ÌïÑÏàò

2. **Ïû¨Í≥† Í¥ÄÎ¶¨**
   - ÎèôÏãúÏÑ± Ï†úÏñ¥ (Ìä∏ÎûúÏû≠ÏÖò)
   - Ïû¨Í≥† ÏòàÏïΩ ÏãúÏä§ÌÖú

3. **ÏÇ¨Ïö©Ïûê Îç∞Ïù¥ÌÑ∞**
   - Í∞úÏù∏Ï†ïÎ≥¥ ÏïîÌò∏Ìôî
   - GDPR Ï§ÄÏàò

## ÏÑ±Îä• ÏµúÏ†ÅÌôî

1. **Ïù¥ÎØ∏ÏßÄ ÏµúÏ†ÅÌôî**
   - Next.js Image Ïª¥Ìè¨ÎÑåÌä∏ ÏÇ¨Ïö©
   - WebP Ìè¨Îß∑ ÏßÄÏõê
   - ÏßÄÏó∞ Î°úÎî©

2. **Ï∫êÏã± Ï†ÑÎûµ**
   - Redis Ï∫êÏã±
   - CDN ÌôúÏö©
   - Ï†ïÏ†Å ÏÉùÏÑ± (ISR)

3. **Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ ÏµúÏ†ÅÌôî**
   - Ïù∏Îç±Ïä§ ÏµúÏ†ÅÌôî
   - ÏøºÎ¶¨ ÏµúÏ†ÅÌôî
   - Ïª§ÎÑ•ÏÖò ÌíÄÎßÅ

## ÌÖåÏä§Ìä∏

```typescript
// __tests__/products.test.ts
describe('Product API', () => {
  it('should fetch products with filters', async () => {
    const response = await fetch('/api/products?category=electronics&minPrice=10000');
    const data = await response.json();
    
    expect(response.status).toBe(200);
    expect(data.products).toBeInstanceOf(Array);
  });
});
```

## Î∞∞Ìè¨ Ï≤¥ÌÅ¨Î¶¨Ïä§Ìä∏

- [ ] ÌôòÍ≤ΩÎ≥ÄÏàò ÏÑ§Ï†ï
- [ ] Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ ÎßàÏù¥Í∑∏Î†àÏù¥ÏÖò
- [ ] Í≤∞Ï†ú ÏãúÏä§ÌÖú ÌîÑÎ°úÎçïÏÖò ÌÇ§
- [ ] SSL Ïù∏Ï¶ùÏÑú
- [ ] CDN ÏÑ§Ï†ï
- [ ] Î™®ÎãàÌÑ∞ÎßÅ ÏÑ§Ï†ï
- [ ] Î∞±ÏóÖ Ï†ÑÎûµ
- [ ] Î°úÎìú ÌÖåÏä§Ìä∏

## Î¨∏Ï†ú Ìï¥Í≤∞

### ÏùºÎ∞òÏ†ÅÏù∏ Î¨∏Ï†úÎì§

1. **Ïπ¥Ìä∏ ÎèôÍ∏∞Ìôî Î¨∏Ï†ú**
   - Î°úÍ∑∏Ïù∏ Ïãú Í≤åÏä§Ìä∏ Ïπ¥Ìä∏ Î≥ëÌï©
   - ÏÑ∏ÏÖò ÎßåÎ£å Ï≤òÎ¶¨

2. **Ïû¨Í≥† Î∂àÏùºÏπò**
   - Ï†ïÍ∏∞Ï†ÅÏù∏ Ïû¨Í≥† Í≤ÄÏ¶ù
   - Ìä∏ÎûúÏû≠ÏÖò Í≤©Î¶¨ ÏàòÏ§Ä Ï°∞Ï†ï

3. **Í≤∞Ï†ú Ïã§Ìå®**
   - Ïû¨ÏãúÎèÑ Î°úÏßÅ
   - Î∂ÄÎ∂Ñ ÌôòÎ∂à Ï≤òÎ¶¨

## Ï∂îÍ∞Ä Î¶¨ÏÜåÏä§

- [Prisma Î¨∏ÏÑú](https://www.prisma.io/docs)
- [Next.js Ïª§Î®∏Ïä§](https://nextjs.org/commerce)
- [Toss Payments Î¨∏ÏÑú](https://docs.tosspayments.com)
- [Vercel Î∞∞Ìè¨ Í∞ÄÏù¥Îìú](https://vercel.com/docs)